---
title: "Linearly Transformed Cosines 详解与实现"
categories:
  - Fractal
date:   2018-01-31 20:54:00 +0800
tags:
  - Lighting
  - Graphics
---

<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"> </script>

<center><img src="/assets/images/ltc/ltc0.png"></center>
<br/>

## 简介
近年来最优秀的一个实时面光源光照算法，出自2016年 Eric Heitz 的 [paper][1]，这个算法巧妙地解决了难以在 polygon 上计算复杂 BRDF 的积分的问题，让面光源也可以放心地用在 shader demo 中，虽然目前我还没想到非常适合展示面光源的 demo，不过还是先写下这篇笔记，帮助大家快速理解论文中的思想和一些推导的过程。

## 算法
在实时计算中，面光源的计算一般没法通过采样来做，所以最好就是能找到渲染方程的解析解，无奈的是，对于复杂的 BRDF， 要么解析解也是计算量非常大，要么就根本找不到。所以当前解析解只限于简单的，类似于 cosine 分布的 BRDF， 也就是说，对于方程：

$$I = \int_{polygon}L(w_i)f(w_0,w_i)cos\theta_idw_i$$

中的 BRDF 函数 $$f$$ 来说， 如果它就是简单的 cosine 分布，那么这个积分是有解析解的。

于是，对于更加复杂（也能更加真实地模拟材质）的 BRDF 来说，这篇论文的核心思想就是：

1. 用一个 3x3 的矩阵 M 把 cosine 分布变换成其他流行的 BRDF， 比如目前效果最好的 GGX， 注意这里的变换是一个近似。
2. 然后再将问题 ” 变换后的 BRDF 在 polygon $$P$$ 上的积分“ 转化为 ” cosine 分布在 polygon $$M^{-1}P$$ 上的积分 “。也就是说我们只需要逆变换 polygon 的顶点， 然后计算一个已知有解析解的积分即可。

由于步骤 1 是在预先通过拟合得到矩阵，存在纹理中，所以这个算法所带来的额外开销非常小。

### 推导与论证
知道了核心思想，接下来看看到底这个方法的理论依据是什么。
论文的基石在于下面这个等式， 也就是描述了上文中的步骤 2：

$$\int_P D(w) dw = \int_{P_o} D_o(w_o)dw_o \tag 1$$

其中 $$P_o$$为多边形面光源顶点，$$P$$为经矩阵$$M$$变换后的多边形面光源顶点，$$D_o$$为原分布函数，通常人为选择为 cosine 分布，$$D$$为经$$M$$变换后的分布函数，$$w_o$$为$$D$$中的单位方向向量， $$w$$为变换后的单位方向向量，可知：

 $$P_o = M^{-1}P$$
 
 $$w={ M w_o \over ||Mw_o|| }$$
 
 $$w_o={ M^{-1} w \over ||M^{-1}w|| }$$

那么（1）式为什么成立呢，首先，论文中给出了：

$$D(w) = D_o(w_o){ \partial w_o \over \partial w } = D_o({ M^{-1}w \over  ||M^{-1}w|| }){ |M^{-1}| \over ||M^{-1}w||^3 } \tag 2$$

这个式子表示了变换后的分布函数值等于原分布函数值乘上该线性变换的雅可比行列式值，注意雅可比行列式的值也就是该变换所带来的缩放因子，论文在附录中给出了该式子的推导，由于这个式子是在理论部分最关键的一块，所以在这里我尝试详细解释一遍。

<center><img src="/assets/images/ltc/ltc1.png"></center>
<br/>

上图左图中红色部分为球面多边形微元，在球为单位球的情况下，这个多边形面积即为$$w_0$$方向上的立体角大小，我们首先在这个球面多边形微元上构建正交标架 $$(w_0, w_1, w_2)$$，三个向量为正交单位向量，那么由向量叉积可知，单位球面多边形的面积即为向量$$w_0=w_1 \times w_2$$的长度，那么球面多边形微元的面积即为向量微元 $$dw_o$$的长度，如果将$$w_o$$看做立体角，那么向量微元的长度就可以表示为立体角微元 $$dw_o$$， 论文中用的偏微分符号表示，我感觉这里应该表达的意思一致。

当我们用矩阵 $$M$$ 变换了这个标架之后，原先的球面多边形微元被变换为右图中红色的多边形微元，那么这个变换将多边形微元的大小改变了多少呢？
我们可以从变换前后两个标架下单位多边形的大小改变推知：因为新的标架为 $$(Mw_0, Mw_1, Mw_2)$$, 那么在此标架下的单位多边形面积与原标架下单位多边形面积之比为：
$$A={ ||Mw_1 \times Mw_2|| \over ||w_1 \times w_2|| } = ||Mw_1 \times Mw_2||$$

那么对于原来的球面多边形微元（左图红色区域）来说，要得到变换后的多边形微元大小（右图中红色区域）就也要乘上这个比例，也就等于（这里写法还是与论文中保持一致）：
$$\partial w_o A$$

右图中绿色的部分表示变换后立体角微元的大小 $$\partial w$$，这样就可以建立变换前后立体角微元间的关系，由任意曲面对应立体角大小的公式可得，变换后新的立体角大小为：

$$\partial w = \partial w_o A{ cos\theta \over r^2 }$$

也就是变换后的多边形微元（右图红色部分）在球面上的投影面积（右图绿色部分），最后再将上式展开化简（化简方法见论文，不再赘述），即可得到雅可比的值：
$${ \partial w_o \over \partial w } = { |M^{-1}| \over ||M^{-1}w||^3 }$$

有了式（2）之后，带入积分即可得到式（1）。

<br>
<br>

回到要求解的渲染方程：

$$I = \int_P L(w_l) f(w_v, w_l) cos\theta_l dw_l$$

其中$$w_l$$为light direction，$$w_v$$ 为view direction， 由于我们已经用变换后的分布函数$$D(w)$$代替 BRDF，所以渲染方程变换为：

$$I = \int_P L(w_l)D(w_l)dw_l$$

再假设面光源的辐射度是均匀的，那么$$L(w_l)$$为常数，可以挪到积分之外：

$$I = L\int_P D(w_l)dw_l = L\int_{P_o}D_o(w_o)dw_o = E(P_o)$$

$$E(P_o)$$表示cosine分布在多边形上的积分，也就是polygon上的照度，所以用 E 表示。前面提到过这个积分是有解析解的，也就是对多边形的每一条边计算：

$$E(P_o) = E(P_1, ..., P_n) = \\ {1\over2\pi}\sum_{i=0}^nacos(<P_i, P_j>)<{ P_i \times P_j \over ||P_i \times P_j||} , {\begin{bmatrix}
    0\\
    0\\
    1\\
    \end{bmatrix}}>  \tag 3$$
    
其中 $$j = (i + 1) \mod n $$


## 算法实现步骤

1. 在实现中，变换矩阵 M 是提前拟合好，并且存储在纹理中，由于分布函数的对称性，对于 3x3 的变换矩阵，我们实际上只需要存储 4 个参数（详细见paper），再加上渲染方程积分的归一化参数，一共5个参数，以视线方向与法线的夹角$$\theta_v$$和表面粗糙程度参数$$\alpha$$作为 index 来采样一个二维的参数纹理，纹理的采样还可以顺便提供给我们线性插值。

2. 假设 N, V, P 为要计算光照的点的法向，视向和位置。
3. Points 为多边形光源的顶点数组，假设这里为4边形。
4. 首先在P点建立本地正交标架 N, T1, T2, 然后把变换矩阵 $$M^{-1}$$ 变换到这个标架中。
5. 点P与多边形光源的4个顶点的向量，即为顶点在本地标架中的位置，设为L[4]，将这些顶点用 $$M^{-1}$$ 变换。
6. 因为$$E(P_o)$$是假设多边形位于上半球面的，所以需要将多边形 L 对 y=0 平面进行裁剪，对于4边形，裁剪最多可能增加一条边，所以裁剪后的多边形为 L[5]。
7. 多裁剪后的所有剩余边，计算（3）式，也就是对 cosine 分布在变换后的多边形上积分。
8. 返回结果。


官方的 shader 实现已经非常简单易懂，但是没有在 shader 中给出矩阵的设置，我在我的 shader ： https://www.shadertoy.com/view/4tBBDK 中集成了这一部分 code，方便大家在自己的 demo 中使用，并且我将算法 port 到了 raymarching 的框架下，而不是原实现中基于 raytracing 的方法。

[1]: https://drive.google.com/open?id=0BzvWIdpUpRx_d09ndGVjNVJzZjA